
## Парсерные комбинаторы

Надо создать два приложения. Оформить их как gradle-проекты.

Если не знаете, как - спросите, я помогу (знание Gradle не является
вашей прямой обязанностью в рамках данного курса :).

## Частичный анализ JVM-байткода

Частичный - потому что 200 байткодов разбирать утомительно и это рутинная работа,
которая погоды не делает.

Принципиально - сделать методом парсер-комбинаторов, который был объяснен на последнем
семинаре.

Императивный разбор "в лоб" решением не считается.

Спецификация класс-файла находится
[здесь](https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-4.html#jvms-4)

Она обратно-совместима - классы более ранних версий ею тоже корректно описываются.

Хотим получить приложение, которое принимает параметром командной строки имя класс-файла
и для начала проверяет по magic-числу, что это похоже на класс-файл.

Если нет - печает разумное сообщение об ошибке и прекращает работу.
Подумайте, как такую проверку вписать в идеологию парсер-комбинаторов.

В дальнейшем - любые непредсказуемые значения должны также приводить к к прекращению
работу с сообщением. Сделайте это в идеологии парсер-комбинаторов, без исключений,
в классах типа Either или Try.

Если все хорошо (в конце, когда ясно, что все действительно хорошо), надо напечатать

* Версию класс-файла

* Модификаторы доступа класса в текстовом виде

* Полное имя класса

* Полное имя суперкласса

* Имена интерфейсов 

* Имена, сигнатуры и права доступа полей

* Имена, сигнатуры и права доступа методов

Типы данных должны быть напечатаны в понятном обычному человеку
виде, не внутренние представления разбираемого формата.

Для последних трех пунктов вам потребуются данные констант-пула.
Его вы тоже получите в ходе разбора. Только вы его как таковой
печатать не будете, но будете использовать его.

Продумайту удобную и идиоматичную структуру для его хранения.

Сборка utf-8 пусть тоже будет оформлена как парсер-комбинатор.

Там еще есть атрибуты. Атрибуты класса, атрибуты полей, атрибуты
методов. 

В них копать не будем. Напечатаем только имена атрибутов. А их содержимое
проскочим. Проскочим тоже с помощью специального вида парсера, проскакивающего
заданное число байтов.


## Разбор слабого закоса под HTML. Слегка битого

Многие знают Python-библиотеку BeautifulSoup. Она разбирает HTML.

Тем же занимаются в своих целях и браузеры.

Может показаться, что задача разбора HTML - в котором могут
попадаться незакрытые теги и т.п. - это какой-то набор ситуативных
костылей.

Но при использовании парсер-комбинаторов подбор запасных вариантов
интерпретации входа становится не то, чтобы более простым, но более
структурированным.

В частности, мы можем передать контекст в качестве параметра функции,
генерирующей парсер.

Но мы, конечно, не будем здесь заниматься полной спецификацией HTML.

Вместо этого определим такой упрощенный формат:

`<body></body>` - тег, обрамляющий документ.

`<p></p>` - абзац текста

`<div></div>` - последовательность элементов

Текст может идти только внутри `<p></p>` (да, это строже, чем HTML, но мы хотим правила попроще)

И для простоты считаем, что в тексте за пределами тегов нет `<` и `>`, а если они встречаются, то только
как часть тега и у нас нет никаких несбалансированных угловых скобок, каких-то совсем незнакомых тегов,
а также закрывающих, идущих впереди открывающих или без парных открывающих.

Но могут быть забытые закрывающие или забытые пары.

`<body>` встречается один и только один раз - как объемлющий тег всего документа.

Непосредственно внутри `body` может идти последовательность `p` или `div` - вперемежку.

Аналогично - внутри `div`  может идти последовательность `p` или `div` - вперемежку.

Задача - написать приложение, которое принимает, возможно, не очень аккуратный текст такого формата с
вышеуказанными гарантиями и порождает правильно сформатированный эквивалент.
 
Текст вне тегов оборачиваем в `p`. 

Если внутри `<p>` встречаем новый `<p>` или `<div>`, то закрываем `<p>`.

Если внутри `<p>` встречаем `</div>` или `</body>`, то закрываем `<p>`.

Если внутри `<div>` встречаем новый `</boby>`, то закрываем `<div>`.

Если внутри вложенных `<div>` встречаем `<\body>`, то закрываем все  `<\div>`.

Если внезапно встречаем конец файла, то закрываем все незакрытые теги.

Если нет body, оборачиваем в body.

Просто текст без тегов обернем сначала в p, потом в body.

Если я что-то пропустил, попробуйте придумать разумную стратегию сами.

Если затрудняетесь, спросите у меня. Лучше - через чат.

Должно получиться приложение принимающее два имени файла в командной строке - вход и выход.


## Общие моменты

Можно для структур типа Try или Either использовать сторонние функциональные библиотеки.
Использовать библиотеки парсер-комбинаторов нельзя.

В парсинге как таковом var не должен использоваться. Для хранения результатов и преобразований -
можно в меру. Там, где это разумно и уместно.

Постарайтесь по максимуму переиспользовать общую логику, в том числе между задачами.
